import gulp from 'gulp';
import browserify from 'browserify';
import source from 'vinyl-source-stream';
import buffer from 'vinyl-buffer';
import eslint from 'gulp-eslint';
import exorcist from 'exorcist';
import browserSync from 'browser-sync';
import watchify from 'watchify';
import babelify from 'babelify';
import uglify from 'gulp-uglify';
import ifElse from 'gulp-if-else';

import sourcemaps from 'gulp-sourcemaps';
import prefix from 'gulp-autoprefixer';
import sass from 'gulp-sass';
import util from 'gulp-util';

import connect from 'gulp-connect';
import open from 'gulp-open'; //Open a URL in a web browser


const config = {
	port: 9025,
	devBaseUrl: 'http://localhost',
	paths: {
		html: './src/*.html',
		js: './src/scripts/**/*.js?',
		sass: './src/sass/**/*.scss',
		css: './dist/styles/',
		dist: './dist',
		mainJs: './src/scripts/main.jsx'
	}
}

//Start a local development server
gulp.task('connect', function() {
	connect.server({
		root: ['dist'],
		port: config.port,
		base: config.devBaseUrl,
		livereload: true
	});
});

gulp.task('open', ['connect'], function() {
	gulp.src('dist/index.html')
		.pipe(open({ 
			app: 'Google Chrome',
			uri: config.devBaseUrl + ':' + config.port + '/'
		}));
});

log('config.mainJs = ' + config.mainJs);

// Input file.
watchify.args.debug = true;
var bundler = browserify(config.mainJs, watchify.args);

// Babel transform
bundler.transform(babelify.configure({
  sourceMapRelative: 'src'
}));

// On updates recompile
bundler.on('update', bundle);

function bundle() {
  return bundler.bundle()
    .on('error', function(error){
      console.error( '\nError: ', error.message, '\n');
      this.emit('end');
    })
    .pipe(exorcist('dist/scripts/bundle.js.map'))
    .pipe(source('bundle.js'))
    .pipe(buffer())
    // .pipe(ifElse(process.env.NODE_ENV === 'production', uglify))
    .pipe(gulp.dest('dist/scripts'));
}

gulp.task('html', function() {
	log('html task starts');

	gulp.src(config.paths.html)
		.pipe(gulp.dest(config.paths.dist))
		.pipe(connect.reload());

	log('html task ends');
});

gulp.task('sass', function () {
	log('sass task starts');

  gulp.src([config.paths.sass])
	  .pipe(sourcemaps.init())
    .pipe(sass().on('error', sass.logError))
    .pipe(prefix())
    .pipe(sourcemaps.write())
		.pipe(gulp.dest(config.paths.css))
		.pipe(gulp.dest(config.paths.dist))
		.pipe(connect.reload());

	log('sass task ends');
});

gulp.task('lint', () => {
   return gulp.src([config.paths.js, 'gulpfile.babel.js'])
		.pipe(eslint())
    .pipe(eslint.format())
});

gulp.task('js', ['lint'], () => bundle());

// gulp.task('js', ['lint'], function() {
// 	log('js task starts');

// 	browserify(config.paths.mainJs)
// 		.transform(babelify)
// 		.bundle()
// 		.on('error', console.error.bind(console))
// 		// .pipe(sourcemaps.init())
// 		.pipe(exorcist('dist/scripts/bundle.js.map'))
// 		// .pipe(sourcemaps.write('./dist/scripts//maps'))
// 		.pipe(source('bundle.js'))
//     .pipe(buffer())
// 		.pipe(gulp.dest(config.paths.dist + '/scripts'))
// 		.pipe(connect.reload());

// 	log('js task ends');
// });

gulp.task('watch', function() {
	gulp.watch(config.paths.sass, ['sass']);
	gulp.watch(config.paths.html, ['html']);
	gulp.watch(config.paths.js, ['js']);
});

gulp.task('default', ['sass', 'html', 'js', 'open', 'watch']);

///////////
function log(msg) {
	if (typeof(msg) === 'object') {
		for (var item in msg) {
			if (msg.hasOwnProperty(item)) {
				util.log(util.colors.blue(msg[item]));
			}
		}
	}
	else {
		util.log(util.colors.blue(msg));
	}
}
